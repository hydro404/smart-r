<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Camalig Route Simulator</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css"/>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet"/>
<script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"></script>
<style>
html, body { height:100%; margin:0; padding:0; font-family:sans-serif; }
body { display:flex; flex-direction:row; min-height:100vh; }
#panel { width: 300px; overflow-y:auto; padding: 10px; background:#f0f0f0; box-sizing:border-box; }
#map { flex:1; height:100vh; }
#panel {
    width: 300px;
    overflow-y: auto;       /* panel scrolls if content exceeds height */
    padding: 10px;
    background: #f0f0f0;
    box-sizing: border-box;
}

.route-item {
    border: 1px solid #ccc;
    padding: 5px;
    margin-bottom: 5px;
    cursor: pointer;
    word-wrap: break-word;  /* wrap long node text */
    height: auto;           /* let height adjust automatically */
}

.route-item.selected {
    background: #d0ebff;
    border-color: #3399ff;
    word-wrap: break-word;
}


.input-box { margin-bottom:10px; }
label { font-weight:bold; }
button { margin-top:5px; }
@media (max-width:768px){
    body { flex-direction:column; }
    #panel { width:100%; max-height:300px; overflow-y:auto; order:1; z-index:1000; }
    #map { height: calc(100vh - 300px); width:100%; order:0; }
}
@media (max-width:480px){
    #panel { max-height:280px; padding:6px; }
    #map { height: calc(100vh - 280px); }
    .route-item { font-size:0.95em; }
    label { font-size:0.98em; }
}
.leaflet-div-icon { background: none; border: none; }
.node-label { width: 30px !important; height: 30px !important; line-height: 30px; border-radius: 50%; background: green; color: white; text-align: center; font-weight: bold; border: none; }
</style>
</head>
<body>

<div id="panel" class="bg-light p-3">
    <div class="input-box mb-3">
        <label class="form-label">Select Cluster:</label>
        <select id="presetSelect" class="form-select mb-2">
            <option value=""disabled selected>-- Select Cluster --</option>
            <option value="EAST">EAST</option>
            <option value="NORTH">NORTH</option>
            <option value="WEST">WEST</option>
            <option value="POBLACION">POBLACION</option>
        </select>

        <label class="form-label">Select Trip:</label>
        <select id="tripSelect" class="form-select mb-2">
            <option value="" disabled selected>-- Select Trip --</option>
        </select>

        <label class="form-label">Or Dynamic Waypoints:</label>
        <div id="waypointsContainer">
            <input type="text" class="form-control mb-1 waypoint" placeholder="lat,lon (e.g. 13.186272,123.65848)">
        </div>
        <button id="addWaypoint" class="btn btn-secondary w-100 mb-2">+ Add Waypoint</button>
        <button id="simulateBtn" class="btn btn-primary w-100">Simulate Route</button>
    </div>
    <div id="routeList"></div>
</div>

<div id="map"></div>

<script>
// Detect OSRM server
let OSRM_SERVER = "http://127.0.0.1:5000"; // default local
async function detectOSRM() {
    try {
        const res = await fetch("http://127.0.0.1:5000/route/v1/driving/0,0;0,0");
        if (!res.ok) OSRM_SERVER = "https://router.project-osrm.org";
    } catch (e) {
        OSRM_SERVER = "https://router.project-osrm.org";
    }
    console.log("Using OSRM server:", OSRM_SERVER);
}
detectOSRM();

let nodes = [], routeLayers = [], nodeMarkers = [];

// Load road network nodes
fetch("road_network.json").then(res => res.json()).then(data => nodes = data);

// Node coordinates
// NORTH cluster coordinates (0–10)
const NODE_COORDS_NORTH = {
    0: [13.186504, 123.658612],
    1: [13.1888218,123.6644],
    2: [13.18767269,123.6731],
    3: [13.17699561,123.668],
    4: [13.1946683,123.6451],
    5: [13.1990854,123.6717],
    6: [13.1987231,123.6374],
    7: [13.20025038,123.6552],
    8: [13.18206941,123.661],
    9: [13.17622371,123.6498],
    10:[13.17930548,123.6325]
};

// EAST cluster coordinates (keep your original or separate if needed)
const NODE_COORDS_EAST = {
    0:  [13.186504, 123.658612],
    1:  [13.17179403, 123.661],
    2:  [13.16666488, 123.6536],
    3:  [13.15759358, 123.662],
    4:  [13.1557856,  123.6523],
    5:  [13.14877073, 123.6649],
    6:  [13.14246553, 123.6578],
    7:  [13.15199952, 123.6424],
    8:  [13.13267441, 123.6481],
    9:  [13.1356055,  123.6688],
    10: [13.13111708, 123.6596],
    11: [13.11500606, 123.6602],
    12: [13.11859982, 123.6463],
    13: [13.09831781, 123.6523],
    14: [13.09580123, 123.6644],
    15: [13.07517471, 123.6608],
    16: [13.06468681, 123.6699],
    17: [13.09396687, 123.6334],
    18: [13.07816417, 123.6426]
};

const NODE_COORDS_POBLACION = {
    0: [13.186504, 123.658612],
    1: [13.18676963,123.6573],
    2: [13.18533555,123.6522],
    3: [13.18617687,123.6503],
    4: [13.1860181,123.6459],
    5: [13.18006194,123.6556],
    6: [13.17880965,123.6556],
    7: [13.18161537,123.6561]
};

// WEST cluster coordinates (1–15)
const NODE_COORDS_WEST = {
    0:  [13.186504, 123.658612],
    1:  [13.16683524, 123.6396],
    2:  [13.16600472, 123.623],
    3:  [13.15008081, 123.618],
    4:  [13.13334241, 123.6104],
    5:  [13.12310983, 123.5987],
    6:  [13.14540131, 123.629],
    7:  [13.10785354, 123.5828],
    8:  [13.11880835, 123.6214],
    9:  [13.10958705, 123.5987],
    10: [13.11839071, 123.6353],
    11: [13.10266989, 123.6062],
    12: [13.09422393, 123.5959],
    13: [13.09670044, 123.616],
    14: [13.07668081, 123.6303],
    15: [13.09398764, 123.5717264]
};



// Predefined trips for clusters
const PRESETS = {
    "EAST": [
        [0,1,3], [0,3,5,6], [0,6,10,11], [0,11],
        [0,11,13,14,15], [0,15,16,18], [0,18,17,12,8],
        [0,8,7], [0,7,4], [0,4,2,9]
    ],
    "NORTH": [
        [0,1,8,0],
        [0,8,3,0],
        [0,3,2,0],
        [0,2,5,9,0],
        [0,9,10,0],
        [0,10,0],
        [0,10,4,6,0],
        [0,6,7,0],
        [0,7,0]
    ],
    "WEST": [
        [0,1,0],
        [0,1,0],
        [0,1,2,0],
        [0,2,3,0],
        [0,3,4,0],
        [0,4,5,9,0],
        [0,9,12,11,13,8,0],
        [0,8,10,7,0],
        [0,7,6,15,14,0]
    ],
    "POBLACION": [
    [0,1,7,5,6,2,0],
    [0,2,3,4,0]
    ]
};


function distance(lat1, lon1, lat2, lon2){
    const R = 6371000;
    const dLat = ((lat2-lat1)*Math.PI)/180;
    const dLon = ((lon2-lon1)*Math.PI)/180;
    const a = Math.sin(dLat/2)**2 + Math.cos(lat1*Math.PI/180)*Math.cos(lat2*Math.PI/180)*Math.sin(dLon/2)**2;
    return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
}

function nearestNode(lat, lon){
    let minDist = Infinity, nearest = null;
    for(let n of nodes){
        const d = distance(lat, lon, n.lat, n.lon);
        if(d < minDist){ minDist = d; nearest = n; }
    }
    return nearest;
}

// Initialize map
const map = L.map('map').setView([13.18,123.66],13);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {maxZoom:19}).addTo(map);

// Add dynamic waypoint input
document.getElementById("addWaypoint").addEventListener("click", ()=>{
    const input = document.createElement("input");
    input.type = "text";
    input.className = "form-control mb-1 waypoint";
    input.placeholder = "lat,lon";
    document.getElementById("waypointsContainer").appendChild(input);
});

// When cluster changes, fill trips
document.getElementById("presetSelect").addEventListener("change", ()=>{
    clearMap();
    const cluster = document.getElementById("presetSelect").value;
    const tripSelect = document.getElementById("tripSelect");
    tripSelect.innerHTML = `<option value="">-- Select Trip --</option>`;
    if(!cluster || !PRESETS[cluster]) return;

    PRESETS[cluster].forEach((trip, i)=>{
        const option = document.createElement("option");
        option.value = i;
        option.text = `Trip [${trip.join(",")}]`;
        tripSelect.appendChild(option);
    });
});

// When trip is selected, fill waypoints and map
document.getElementById("tripSelect").addEventListener("change", ()=>{
    clearMap();
    const cluster = document.getElementById("presetSelect").value;
    if(!cluster) return;
    const index = parseInt(document.getElementById("tripSelect").value);
    if(isNaN(index)) return;

    const tripNodes = PRESETS[cluster][index];
    let clusterCoords;
    if(cluster === "NORTH") clusterCoords = NODE_COORDS_NORTH;
    else if(cluster === "EAST") clusterCoords = NODE_COORDS_EAST;
    else if(cluster === "POBLACION") clusterCoords = NODE_COORDS_POBLACION;
    else if(cluster === "WEST") clusterCoords = NODE_COORDS_WEST;
    else clusterCoords = NODE_COORDS; // fallback

    const coordsList = tripNodes.map(n => clusterCoords[n]);

    const container = document.getElementById("waypointsContainer");
    container.innerHTML = "";
    coordsList.forEach(c=>{
        const input = document.createElement("input");
        input.type = "text";
        input.className = "form-control mb-1 waypoint";
        input.value = c.join(",");
        container.appendChild(input);
    });

    // Automatically simulate this trip
    simulateRoute(coordsList);
});

// Simulate button
document.getElementById("simulateBtn").addEventListener("click", ()=>{
    const waypointInputs = document.querySelectorAll(".waypoint");
    const coordsList = [];
    waypointInputs.forEach(input=>{
        if(input.value.trim()==="") return;
        const [lat, lon] = input.value.split(",").map(Number);
        coordsList.push([lat, lon]);
    });
    if(coordsList.length < 2){ alert("Add at least 2 waypoints"); return; }
    simulateRoute(coordsList);
});

function clearMap() {
    routeLayers.forEach(l => map.removeLayer(l));
    routeLayers = [];
    nodeMarkers.forEach(m => map.removeLayer(m));
    nodeMarkers = [];
    document.getElementById("routeList").innerHTML = "";
}

// Function to simulate route
// Function to simulate route with alternatives
async function simulateRoute(coordsList){
    // Clear old routes, retain markers
    routeLayers.forEach(l=>map.removeLayer(l));
    routeLayers = [];

    const osrmCoords = coordsList.map(c=>`${c[1]},${c[0]}`).join(";");
    const urlForward = `${OSRM_SERVER}/route/v1/driving/${osrmCoords}?overview=full&geometries=geojson&steps=true&alternatives=true`;
    const urlReturn = `${OSRM_SERVER}/route/v1/driving/${coordsList.slice().reverse().map(c=>c[1]+","+c[0]).join(";")}?overview=false&geometries=geojson&steps=false`;

    const [forwardData, returnData] = await Promise.all([
        fetch(urlForward).then(res=>res.json()),
        fetch(urlReturn).then(res=>res.json())
    ]);

    if(!forwardData.routes || forwardData.routes.length===0){ alert("No forward routes found"); return; }

    const routeListDiv = document.getElementById("routeList");
    routeListDiv.innerHTML = "";

    forwardData.routes.forEach((route, i)=>{
        const coords = route.geometry.coordinates.map(c=>[c[1],c[0]]);
        const layer = L.polyline(coords,{color:'blue',weight:4,opacity:0.5}).addTo(map);
        routeLayers.push(layer);

        let passedLabels = [];
        route.legs.forEach(leg=>{
            leg.steps.forEach(step=>{
                step.intersections.forEach(inter=>{
                    const nearest = nearestNode(inter.location[1], inter.location[0]);
                    if(nearest && !passedLabels.includes(nearest.label)) passedLabels.push(nearest.label);
                });
            });
        });
        passedLabels.unshift("0"); passedLabels.push("0");

        if(i===0){
            // Display numbered markers for first route
            nodeMarkers.forEach(m=>map.removeLayer(m));
            nodeMarkers = [];
            passedLabels.forEach((label, idx)=>{
                const node = nodes.find(n=>n.label===label);
                if(node){
                    const icon = L.divIcon({className:'node-label', html: idx+1});
                    const marker = L.marker([node.lat,node.lon],{icon:icon}).addTo(map);
                    nodeMarkers.push(marker);
                }
            });
        }

        const totalDistance = route.distance + returnData.routes[0].distance;
        const totalDuration = route.duration + returnData.routes[0].duration;

        const item = document.createElement("div");
        item.className = "route-item";
        item.innerHTML = `<b>Trip ${i+1}: ${(totalDistance/1000).toFixed(2)} km</b> - ${Math.round(totalDuration/60)} min<br>Nodes: [${passedLabels.join(",")}]`;
        
        // Add click to select alternative route
        item.addEventListener("click", ()=>{
            routeLayers.forEach(l=>l.setStyle({opacity:0.3,color:"blue"}));
            layer.setStyle({opacity:1,color:"red"});
            routeListDiv.querySelectorAll(".route-item").forEach(el=>el.classList.remove("selected"));
            item.classList.add("selected");

            // Update markers for selected route
            nodeMarkers.forEach(m=>map.removeLayer(m));
            nodeMarkers = [];
            passedLabels.forEach((label, idx)=>{
                const node = nodes.find(n=>n.label===label);
                if(node){
                    const icon = L.divIcon({className:'node-label', html: idx+1});
                    const marker = L.marker([node.lat,node.lon],{icon:icon}).addTo(map);
                    nodeMarkers.push(marker);
                }
            });

            map.fitBounds(layer.getBounds());
        });

        routeListDiv.appendChild(item);
    });

    // Automatically select first route
    if(routeLayers[0]){
        routeLayers[0].setStyle({color:'red',opacity:1});
        routeListDiv.firstChild.classList.add('selected');
        map.fitBounds(routeLayers[0].getBounds());
    }
}

</script>
</body>
</html>
